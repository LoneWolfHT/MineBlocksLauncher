<html>
<head>
	<title>Frisbio</title>
	<link rel="stylesheet" type="text/css" href="style.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script src="/three/three.min.js"></script>
	<script src="perlin.js"></script>
	<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-25460606-9','auto');ga('send','pageview');</script>
	<script id="mapVS" type="x-shader/x-vertex">
	varying vec2 fuv;
	varying vec3 norm;
	varying vec3 pos;
	void main() {
		fuv = uv;
		norm = normal;
		pos = position.xyz;
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
	</script>
	
	<script id="mapFS" type="x-shader/x-fragment">
	#define whiteCompliment(a) (1.0-saturate(a))
	#define LOG2 1.442695
	
	varying vec2 fuv;
	varying vec3 norm;
	varying vec3 pos;
	uniform sampler2D t1;
	uniform sampler2D t2;
	uniform vec3 sky;
	
	void main() {
		float depth = gl_FragCoord.z/gl_FragCoord.w;
		float fogFactor = whiteCompliment(exp2(-.002*.002 * depth*depth * LOG2));
		
		gl_FragColor.rgb = mix(texture2D(t2, fuv).rgb, texture2D(t1, fuv).rgb, clamp(pos.y*.5+2.0, 0.0, 1.0))*pow(dot(norm, vec3(0.0, 1.0, 0.0)), 20.0);
		
		gl_FragColor.rgb = mix(gl_FragColor.rgb, sky, fogFactor);
	}
	</script>
	
</head>
<body>
	<div id="fb-root"></div><script>(function(d, s, id) {var js, fjs = d.getElementsByTagName(s)[0];if (d.getElementById(id)) return;js = d.createElement(s); js.id = id;js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.8&appId=737723989640673";fjs.parentNode.insertBefore(js, fjs);}(document, 'script', 'facebook-jssdk'));</script>
	<div id="game" oncontextmenu="return false;">
		<div id="plates" style="z-index:2;position:absolute;width:100%;height:100%;text-align:center;pointer-events:none">
		</div>
	</div>
	<div id="mainMenu">
		<div class="strip"><div class="panel" style="text-align:center;font-size:40px;">
				FRISBIO COMING SOON
				<hr style="height:1px;color:#000000;margin-top:5px;margin-bottom:7px;" size=1 />
				<div class="fb-like" data-href="https://facebook.com/frisbiogame" data-layout="button" data-action="like" data-size="small" data-show-faces="false" data-share="false"></div>
				<a href="https://twitter.com/frisbio" class="twitter-follow-button" data-show-count="false" style="font-size:20px;">@Frisbio on Twitter</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
			</div>
		</div>
	</div>
<script>
(function(){

function replaceThreeChunkFn(a, b) {
    return THREE.ShaderChunk[b] + '\n';
}
function shaderParse(glsl) {
    return glsl.replace(/\/\/\s?chunk\(\s?(\w+)\s?\);/g, replaceThreeChunkFn);
}

noise.seed(1337);

var FPS = 60;

const pi = Math.PI;
const twopi = 2*pi;
const pi2 = pi*pi;

const skyColor = 0x69A8FF;

var camera, scene, renderer, mainLight;
var container = $("#game");
var w = container.width();
var h = container.height();
var textureLoader = new THREE.TextureLoader();

var mapSize = 100;
var mapStretch = 16;
var hillHeight = 8;

var mapBounds = {left:-(mapSize-4)*mapStretch/2, right:(mapSize-2-4)*mapStretch/2, top:(mapSize-2-4)*mapStretch/2, bottom:-(mapSize-4)*mapStretch/2};
mapBounds.width = (mapBounds.right-mapBounds.left);
mapBounds.height = (mapBounds.top-mapBounds.bottom);


var meshes = {};
var textures = {};
var fris;

var tick = 0;

init();
animate();

function rotateAroundWorldAxis(object, axis, radians) {
    rotWorldMatrix = new THREE.Matrix4();
    rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
    rotWorldMatrix.multiply(object.matrix);
    object.matrix = rotWorldMatrix;
    object.rotation.setFromRotationMatrix(object.matrix);
}
function animate() {
	tick = ++tick%Number.MAX_SAFE_INTEGER;
	
	setTimeout(function() {requestAnimationFrame(animate);}, 1/FPS);
	
	camera.position.set(Math.sin(tick/3000)*300, 10, Math.cos(tick/3000)*300);
	camera.rotation.set(0, tick/3000, 0);
	
	fris.matrix = new THREE.Matrix4();
	fris.matrix.makeRotationAxis(new THREE.Vector3(1, 0, 0), -.8);
	rotateAroundWorldAxis(fris, new THREE.Vector3(0, 1, 0), 2.7+Math.sin(tick/425)*.2+tick/3000);
	
	fris.position.set(Math.sin(tick/3000)*297+Math.sin(tick/265)*.1, 10.16+Math.sin(tick/378)*.07, Math.cos(tick/3000)*297+Math.sin(tick/233)*.1);
	//fris.rotation.set(.8, -tick/30, 0);
	
	w = container.width();
	h = container.height();
	if (renderer.domElement.width !== w || renderer.domElement.height !== h) {
		ASPECT = w/h;
		camera.aspect = ASPECT;
		camera.updateProjectionMatrix();
		renderer.setSize(w, h);
	}
	
	renderer.render(scene, camera);
}



function init() {
	var mapVS = shaderParse($("#mapVS").text());
	var mapFS = shaderParse($("#mapFS").text());
	
	w = container.width();
	h = container.height();
	
	generateMeshes();
	
	camera = new THREE.PerspectiveCamera(40, w/h, 1, 1000);
	camera.position.set(0, 0, 0);
	camera.lookAt(new THREE.Vector3(0, 0, 0));
	scene = new THREE.Scene();
	
	scene.fog = new THREE.FogExp2(skyColor, 0.002);
	
	// Lights
	scene.add(new THREE.AmbientLight(0xAADDFF, .7));
	
	mainLight = new THREE.DirectionalLight( 0xFFFFFF, 0.6 );
	mainLight.position.set(0, 100, 0);
	
	scene.add(mainLight);
	
	// Renderer
	renderer = new THREE.WebGLRenderer();
	renderer.antialias = true;
	renderer.setSize(w, h);
	renderer.setClearColor(skyColor);
	
	container.append(renderer.domElement);
	container.resize(function() {onResize();});
	onResize();
	
	
	fris = new THREE.Group();
	loadTexture("disc.png");
	
	var fris1 = new THREE.Mesh(
		meshes["disc"],
		new THREE.MeshPhongMaterial({color: 0xFFFFFF, shading:THREE.SmoothShading, side:THREE.FrontSide, map:textures["disc.png"]})
	);
	var fris2 = new THREE.Mesh(
		meshes["discReverse"],
		new THREE.MeshPhongMaterial({color: 0xFFFFFF, shading:THREE.SmoothShading, side:THREE.BackSide, map:textures["disc.png"]})
	);
	fris.add(fris1);
	fris.add(fris2);
	scene.add(fris);
	
	
	loadTexture("Grass.png");
	loadTexture("dirt.png");
	var material = new THREE.ShaderMaterial({
		uniforms: {
			"sky":{type:"c", value:new THREE.Color(skyColor)},
			"t1":{type:"uTex", value:textures["Grass.png"]},
			"t2":{type:"uTex", value:textures["dirt.png"]}
		},
		vertexShader: mapVS,
		fragmentShader: mapFS
	});
	var map = new THREE.Mesh(meshes["map"], material);
	scene.add(map);
	
	scene.add(camera);
	// Start
	startTime = Date.now();
	time = 0;
}


function addDisc(texture) {
	var obj = new THREE.Group();
	loadTexture(o.texture);
	var fris1 = new THREE.Mesh(
		meshes["disc"],
		new THREE.MeshPhongMaterial({color: 0xFFFFFF, shading:THREE.SmoothShading, side:THREE.FrontSide, map:texture})
	);
	var fris2 = new THREE.Mesh(
		meshes["discReverse"],
		new THREE.MeshPhongMaterial({color: 0xFFFFFF, shading:THREE.SmoothShading, side:THREE.BackSide, map:texture})
	);
	fris2.castShadow = true;
		
	obj.add(fris1);
	obj.add(fris2);
	
	scene.add(entities[o.id].obj);
	return obj;
}

function loadTexture(texture) {
	if(textures[texture] == undefined) {
		textures[texture] = textureLoader.load("assets/images/"+texture);
		textures[texture].magFilter = THREE.LinearFilter;
		textures[texture].minFilter = THREE.LinearMipMapNearestFilter;
		textures[texture].anisotropy = 8;
		textures[texture].wrapS = THREE.RepeatWrapping;
		textures[texture].wrapT = THREE.RepeatWrapping;
	}
}
function generateMeshes() {
	meshes["disc"] = generateMesh("disc");
	meshes["discReverse"] = generateMesh("disc", true);
	meshes["map"] = generateMesh("map");
}
function modulus(a, b) {
	var c = a % b;
	return (c < 0) ? c + b : c;
}
function rott(r, w, a) {
	//R is original
	var c = Math.cos(a);
	var s = Math.sin(a);
	return {x:(c+w.x*w.x*(1-c))*r.x + (w.x*w.y*(1-c)-w.z*s)*r.y + (w.y*s+w.x*w.z*(1-c))*r.z, y:(w.z*w.z*s+w.x*w.y*(1-c))*r.x + (c+w.y*w.y*(1-c))*r.y + (-w.x*s+w.y*w.z*(1-c))*r.z, z:(-w.y*s+w.x*w.z*(1-c))*r.x + (c+w.z*w.z*(1-c))*r.z + (w.x*s+w.y*w.z*(1-c))*r.y};
}
function proj(v, n) {
	var dot = v.x*n.x+v.y*n.y+v.y*n.z;
	return {x:v.x-dot*n.x, y:v.y-dot*n.y, z:v.z-dot*n.z}
}
function cros(a, b) {
	return {x:a.y*b.z-a.z*b.y, y:a.z*b.x-a.x*b.z, z:a.x*b.y-a.y*b.x};
}
function leng(v) {
	return Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}
function normal(v) {
	var len = leng(v);
	return {x:v.x/len, y:v.y/len, z:v.z/len};
}
function generateMesh(type, reverse) {
	var geometry = new THREE.BufferGeometry();
	var vertices = [];
	var indices = [];
	var uv = [];
	switch(type) {
		case "disc":
			var plot = [
				[0.000, 0.000],
				[0.211, 0.000],
				[0.516, 0.094],
				[0.780, 0.281],
				[0.929, 0.531],
				[0.992, 0.781],
				[1.000, 1.000]
			];
			var radius = 1;
			var height = .3;
			var rings = 45;
			for(var ang = 0; ang<rings; ang++) {
				for(var strip = 0; strip<plot.length; strip++) {
					vertices.push(
						Math.cos(ang/rings *twopi)*plot[strip][0]*radius, -(plot[strip][1]-.5)*height, Math.sin(ang/rings *twopi)*plot[strip][0]*radius
					);
					uv.push(
						.5+(reverse?1:-1)*Math.cos(ang/rings *twopi)*plot[strip][0]*.49, .5+Math.sin(ang/rings *twopi)*plot[strip][0]*.49
					);
					if(strip != plot.length-1) {
						indices.push(ang*plot.length+strip, 		((ang+1)%rings)*plot.length+strip, 	ang*plot.length+(strip+1));
						indices.push(((ang+1)%rings)*plot.length+strip, ((ang+1)%rings)*plot.length+(strip+1),	ang*plot.length+(strip+1));
					}
				}
			}
			break;
		case "map":
			for(var mapX = 0; mapX < mapSize; mapX++) {
				for(var mapY = 0; mapY < mapSize; mapY++) {
					vertices.push((mapX-mapSize/2)*mapStretch, noise.simplex2((mapX-mapSize/2)/10, (mapY-mapSize/2)/10)*hillHeight, (mapY-mapSize/2)*mapStretch);
					uv.push(mapX/2, mapY/2);
					if(mapX > 0 && mapY > 0) {
						indices.push(mapX*mapSize+mapY, (mapX-1)*mapSize+(mapY-1), (mapX-1)*mapSize+mapY);
						indices.push(mapX*mapSize+mapY, mapX*mapSize+(mapY-1), (mapX-1)*mapSize+(mapY-1));
					}
				}
			}
			break;
		default:
			return;
	}
	var vertices32 = new Float32Array(vertices);
	if(type == "trajectory") trajectoryPath = vertices32;
	if(indices.length > 0) {
		var indices32 = new Uint16Array(indices);
		geometry.setIndex(new THREE.BufferAttribute(indices32, 1));
	}
	geometry.addAttribute('position', new THREE.BufferAttribute(vertices32, 3));
	if(uv.length > 0) {
		var uv32 = new Float32Array(uv);
		geometry.addAttribute('uv', new THREE.BufferAttribute(uv32, 2));
	}
	geometry.computeVertexNormals();
	return geometry;
}
function height(x, y) {
	return (noise.simplex2((x/mapStretch)/10, (y/mapStretch)/10)*hillHeight);
}
function onResize() {
	w = container.width();
	h = container.height();
	camera.aspect = w/h;
	camera.updateProjectionMatrix();
	renderer.setSize(w, h);
}
})();
</script>
</body>
</html>